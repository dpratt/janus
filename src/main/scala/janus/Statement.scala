package janus

import org.slf4j.LoggerFactory
import CloseableResource.withResource
import collection.mutable.ArrayBuffer

trait Statement extends CloseableResource {

  /**
   * Execute the SQL statement and return a Boolean specifying success.
   */
  def execute(sql: String): Boolean

  /**
   * Execute the specified query and process the results with the supplied handler
   */
  def executeQuery[A](sql: String)(resultHandler: ResultSet => A): A

  /**
   * Execute the specified update query and return the number of updated rows.
   */
  def executeUpdate(sql: String, returnAutoGeneratedKeys: Boolean = false): Int

  /**
   * Get the generated keys from the most recently executed statement. NOTE - the caller is responsible
   * for closing this ResultSet when done with it.
   */
  def generatedKeys(): ResultSet
}

trait PreparedStatement extends CloseableResource {

  /**
   * Execute the SQL statement contained in this statement and return a Boolean specifying success.
   * @return
   */
  def execute(): Boolean

  /**
   * Execute the query contained in this statement and process the rows with the supplied handler.
   * Each row in the resultset will be mapped using the supplied function.
   * @return
   */
  def executeQuery[A](resultHandler: ResultSet => A): A

  /**
   * Execute the update query represented by this statement and return the number of updated rows.
   */
  def executeUpdate(): Int

  /**
   * Add the current parameter state to this PreparedStatement's batch list.
   */
  def addBatch()

  /**
   * Remove all batched statements from this PreparedStatement.
   */
  def clearBatch()

  /**
   * Execute this PreparedStatement once for each batch of parameters that have been added to it.
   */
  def executeBatch(): Array[Int]

  /**
   * Set the value of a parameter in this statement to the specified value
   * @param value the value to set
   * @tparam T the type of the value
   */
  def setParam[T : ClassManifest](index: Int, value: T)

  /**
   * Clear out all the currently set parameters on this prepared statement.
   */
  def clearParams()

  /**
   * Get the generated keys from the most recently executed statement.
   */
  def generatedKeys[A : ClassManifest](): Seq[A]

}

/**
 * A thin wrapper on top of the JDBC result set.
 *
 * Note - some of the Traversable opertaions on this object have the potential to be
 * *very* slow. For example, size() has to iterate across the whole collection. Be warned.
 */
trait ResultSet extends CloseableResource with Traversable[ResultRow] {

}

trait ResultRow {
  def apply[A : ClassManifest](index: Int): A
  def apply[A : ClassManifest](columnName: String): A
}

sealed class JdbcStatement(stmt: java.sql.Statement) extends Statement {

  import JdbcStatement._

  def close() {
    log.debug("Closing statement")
    stmt.close()
  }

  def failureHandler(e: Throwable) {
    log.debug("Cleaning up statement due to exception - {}", stmt.toString)
    close()
  }

  def execute(sql: String): Boolean = stmt.execute(sql)
  def executeQuery[A](sql: String)(resultHandler: ResultSet => A): A = {
    withResource(JdbcResultSet(stmt.executeQuery(sql)))(resultHandler)
  }
  def executeUpdate(sql: String, returnAutoGeneratedKeys: Boolean): Int = {
    val generatedParams = if (returnAutoGeneratedKeys) {
      java.sql.Statement.RETURN_GENERATED_KEYS
    } else {
      java.sql.Statement.NO_GENERATED_KEYS
    }
    stmt.executeUpdate(sql, generatedParams)
  }

  def generatedKeys(): ResultSet = JdbcResultSet(stmt.getGeneratedKeys)
}

object JdbcStatement {
  val log = LoggerFactory.getLogger(classOf[JdbcStatement])
}

sealed class JdbcPreparedStatement(ps: java.sql.PreparedStatement) extends PreparedStatement {

  import JdbcPreparedStatement._

  def execute(): Boolean = ps.execute()

  def executeQuery[A](resultHandler: ResultSet => A): A = {
    //wrap the JDBC ResultSet
    withResource(JdbcResultSet(ps.executeQuery()))(resultHandler)
  }
  def executeUpdate(): Int = ps.executeUpdate()


  /**
   * Add the current parameter state to this PreparedStatement's batch list.
   */
  def addBatch() {
    ps.addBatch()
  }

  /**
   * Remove all batched statements from this PreparedStatement.
   */
  def clearBatch() {
    ps.clearBatch()
  }

  /**
   * Execute this PreparedStatement once for each batch of parameters that have been added to it.
   */
  def executeBatch(): Array[Int] = {
    ps.executeBatch()
  }

  def setParam[T : ClassManifest](index: Int, value: T) {
    import ClassConstants._
    val m = classManifest[T]
    m.erasure match {
      case StringClass => ps.setString(index, value.toString)
      case IntClass => ps.setInt(index, value.asInstanceOf[Int])
      case DoubleClass => ps.setDouble(index, value.asInstanceOf[Double])
      case DateSQLClass => ps.setDate(index, value.asInstanceOf[java.sql.Date])
      case LongClass => ps.setLong(index, value.asInstanceOf[Long])
      case _ => throw new RuntimeException("Unknown type " + m.toString)
    }
  }


  /**
   * Clear out all the currently set parameters on this prepared statement.
   */
  def clearParams() {
    ps.clearParameters()
  }


  /**
   * Get the generated keys from the most recently executed statement.
   */
  def generatedKeys[A : ClassManifest](): Seq[A] = {
    val rs = ps.getGeneratedKeys
    try {
      val keys = new ArrayBuffer[A]()
      while(rs.next()) {
        keys.append(JdbcResultSet.getValue[A](rs, 1))
      }
      keys
    } finally {
      rs.close()
    }
  }

  def close() {
    log.debug("Closing prepared statement - {}", ps.toString)
    ps.close()
  }

  def failureHandler(e: Throwable) {
    log.error("Closing prepared statement due to exception.")
    close()
  }
}

object JdbcPreparedStatement {
  val log = LoggerFactory.getLogger(classOf[JdbcPreparedStatement])
}

sealed class JdbcResultSet(rs: java.sql.ResultSet) extends ResultSet with ResultRow {

  //this class is both the collection and the element since that's what the underlying
  //JDBC abstraction is
  import JdbcResultSet._

  def foreach[U](f: (ResultRow) => U) {
    rs.beforeFirst()
    while (rs.next()) {
      f(this)
    }
  }

  def apply[A: ClassManifest](index: Int): A = JdbcResultSet.getValue(rs, index)
  def apply[A: ClassManifest](columnName: String): A = JdbcResultSet.getValue(rs, columnName)

  def close() {
    log.debug("Closing ResultSet")
    rs.close()
  }

  def failureHandler(e: Throwable) {
    log.error("Closing ResultSet due to exception.")
  }
}

object JdbcResultSet {

  def apply(rs: java.sql.ResultSet) = new JdbcResultSet(rs)

  val log = LoggerFactory.getLogger(classOf[JdbcResultSet])

  def getValue[A: ClassManifest](rs: java.sql.ResultSet, index: Int): A = {
    import ClassConstants._
    val m = classManifest[A]
    (m.erasure match {
      case StringClass => rs.getString(index)
      case IntClass => rs.getInt(index)
      case DoubleClass => rs.getDouble(index)
      case DateSQLClass => rs.getDate(index)
      case LongClass => rs.getLong(index)
      case _ => throw new RuntimeException("Unknown type " + m.toString)
    }).asInstanceOf[A]
  }

  def getValue[A: ClassManifest](rs: java.sql.ResultSet, columnName: String): A = {
    import ClassConstants._
    val m = classManifest[A]
    (m.erasure match {
      case StringClass => rs.getString(columnName)
      case IntClass => rs.getInt(columnName)
      case DoubleClass => rs.getDouble(columnName)
      case DateSQLClass => rs.getDate(columnName)
      case LongClass => rs.getLong(columnName)
      case _ => throw new RuntimeException("Unknown type " + m.toString)
    }).asInstanceOf[A]
  }


}


object ClassConstants {
  //useful constants - we use these for pattern matching
  val StringClass = classOf[String]
  val LongClass = classOf[Long]
  val IntClass = classOf[Int]
  val DoubleClass = classOf[Double]
  val DateSQLClass = classOf[java.sql.Date]
}